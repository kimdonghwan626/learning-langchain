랭체인(LangChain) vs 랭그래프(LangGraph) 차이점 정리
1) 철학의 차이
LangChain = 파이프라인 기반

LLM 호출, 툴 사용, 프롬프트 템플릿을 직렬 파이프라인으로 연결하는 느낌.

“입력 → 처리 → 출력” 구조가 중심.

흐름은 대부분 단방향·순차적.

LangGraph = 상태 기반(State Machine) 그래프

노드(Node) 간의 흐름을 그래프 구조로 명시적으로 만든다.

상태(State)를 지속적으로 유지/업데이트한다.

분기, 루프, 중단/재개가 자연스럽게 되는 아키텍처.

2) 구현적으로 가장 큰 차이
🔹 LangChain만으로는 구현이 어려운 것

아래 기능들은 LangChain 기본 기능으로도 가능은 하지만 복잡하고 버그·제어 어려움이 크다.
LangGraph는 이걸 1급 시민으로 지원함.

① LLM 에이전트의 “상태 관리”

LangChain은 메모리 관리가 단순(대화 기록 저장 수준)

LangGraph는 state(dict)를 계속 누적하면서 각 노드에서 읽고 수정 가능
→ RAG 파이프라인, Multi-step agent 작업에서 훨씬 안정적

② 루프(반복)

예: “답이 맞을 때까지 다시 생성”

LangChain에서는 Runnable의 recursion은 가능하지만 구조적 제어가 어려움

LangGraph에서는 graph.add_conditional_edges 로 명시적 루프 가능

③ 분기(조건 처리)

예:

“에러이면 리트라이로 이동”

“LLM의 판단이 Y라면 ToolNode 실행”

LangChain도 분기 가능은 하지만 코드 가독성·추적성 떨어짐.
LangGraph에서는 분기를 노드 단위로 관리하므로 시각적으로 명료.

④ 중단(suspend) → 재개(resume)

→ 이 기능은 LangChain 단독으로는 거의 불가능
LangGraph는 체크포인트 기반으로 자동 지원:

웹 UI에서 작업 중단

다음 날 이어서 실행

에이전트의 step-by-step 진행 제어

LangGraph의 핵심 강점이 바로 이 기능임.

⑤ 스트리밍 제어(on_event)

LangChain도 스트리밍 지원하지만 "노드 단위 상태 추적"은 약함.

LangGraph는 그래프 전체의 이벤트를 스트림으로 받을 수 있음
→ UI 구성, 중간 단계 디버깅이 훨씬 쉬움

⑥ 멀티 에이전트 협력 구조

예: Planner → ToolAgent → AnswerSynthesizer

LangChain만으로 구현하려면 Runnable이나 각종 Agent 구현을 직접 제어해야 해서 난이도↑

LangGraph는 이를 스테이트 머신 형태로 안정적으로 운영.

3) 개발 편의성 차이
기능	LangChain	LangGraph
상태(state) 공유	제한적	중앙 state를 모든 노드가 읽고 수정
이벤트 스트리밍	기본 제공	그래프 전체 이벤트 지원
중단/재개	없음	체크포인트 기반 재개
복잡한 분기	코드 많아짐	노드 간 조건 연결
루프	비권장/복잡	정식 지원
디버깅	콘솔 중심	LangGraph Studio UI
멀티 에이전트	복잡함	자연스럽게 설계됨
4) 정리 — 한 문장으로

LangChain = LLM 도구 세트 + 파이프라인
LangGraph = LangChain을 기반으로 한 “상태 머신 기반 에이전트 프레임워크”

즉,

LangChain만으로도 대부분 구현 가능하지만

LangGraph는 복잡한 에이전트/멀티스텝 워크플로를 훨씬 안정·명확·간단하게 만든다.

5) 어떤 때 LangGraph를 꼭 써야 하나?
✔ 에이전트가 여러 단계의 판단을 하는 경우
✔ 툴 사용이 많고 반복되는 경우
✔ “답이 나올 때까지 루프” 같은 구조
✔ 멀티 에이전트 협업
✔ 중간 상태 저장/복구 필요
✔ 스트리밍으로 단계별 진행 상황 추적
✔ 그래프 기반 시각화로 디버깅하고 싶은 경우
필요하면

너가 지금 만들려는 구체적인 워크플로우를 말해줘.
→ LangChain만으로 해도 되는지 / LangGraph가 나은지 정확히 안내해줄게!